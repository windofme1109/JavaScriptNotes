<!-- START doctoc generated TOC please keep comment here to allow auto update -->

<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [leetcode-刷题常见技巧-JavaScript](#leetcode-%E5%88%B7%E9%A2%98%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7-javascript)
  - [1. 如何初始化一个数组](#1-%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84)
  - [2. 快速判断一个数是否是 2 的整次幂（$2^n$）](#2-%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF-2-%E7%9A%84%E6%95%B4%E6%AC%A1%E5%B9%822%5En)
  - [3. 使用位运算判断一个整数是奇数还是整数](#3-%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%A5%87%E6%95%B0%E8%BF%98%E6%98%AF%E6%95%B4%E6%95%B0)
  - [4. 快速求一个数的 n 次幂（$x^n$）](#4-%E5%BF%AB%E9%80%9F%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84-n-%E6%AC%A1%E5%B9%82x%5En)
  - [5. 求一个数的平方根](#5-%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9)
    - [1. 二分查找](#1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)
    - [2. 牛顿迭代法](#2-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95)
  - [6. 如何快速从 1 - n 中筛选出素数](#6-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%BB%8E-1---n-%E4%B8%AD%E7%AD%9B%E9%80%89%E5%87%BA%E7%B4%A0%E6%95%B0)
  - [7. 如何反转一个整数](#7-%E5%A6%82%E4%BD%95%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0)
  - [8. 快速求 $n!$ 中末尾 0 的个数](#8-%E5%BF%AB%E9%80%9F%E6%B1%82-n-%E4%B8%AD%E6%9C%AB%E5%B0%BE-0-%E7%9A%84%E4%B8%AA%E6%95%B0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# leetcode-刷题常见技巧-JavaScript

## 1. 如何初始化一个数组

1. Array 构造函数：
   
   ```js
   const arr = Array(n);
   ```
   
   n 是一个大于 0 的数字，这样得到一个元素全部是 `empty` 的数组。
2. Array.from()
   
   ```js
   const arr = Array.from({length: n}, function(item, index) {
         return 0;
      })
   ```
   
   Array.from() 将一个类数组对象转换为真正的数组，同时接收一个回调函数，可以实现对转换后的数组中的数据进行处理，最后返回新的数组。

## 2. 快速判断一个数是否是 2 的整次幂（$2^n$）

1. 位运算：当 `x > 0` 时，`x \& (x - 1) = 0` 可以保证 x 一定是整数。
2. 原理：
   
   - 当 $x > 0$ 时，且 $x = 2^n$，x 的二进制形式一定是 `100...00`
   - $x-1 = 2^n - 1$ 的二进制形式是：`011...11`
   - 举一个例子：8 的二进制形式是：`1000`，7 的二进制形式是：`0111`，所以 `8 & 7 = 0`

## 3. 使用位运算判断一个整数是奇数还是整数

1. 如果 x 是奇数，那么 $x \& 1 = 1$
2. 如果 x 是偶数，那么 $x \& 1 = 0$
3. 原理
   
   - 如果 x 是偶数，则 x 可以写成：$x = 2n, n >= 0$，进一步，x 可以写成：$x = ... + a_4\times8 + a_3\times4 +a_2\times2 + 0 \times 1 = \sum_{i=1}^na_i\times2^{i-1}, a_i = \{0, 1\}$。即 x 可以写成若干个 2 的整次幂之和。从上面的推论中，我们可以得知$a_1\times2^0 = 0$，即 $a_1 = 0$。那么将 x 写成二进制形式，最后一位一定是 0，而 1 的二进制形式一定是：`00...001`，即只有最后一位是 1。所以，综上所述，`x & 1 = 0`。
   - x 如果是奇数，则 x 可以写成：$x = 2n + 1, n >= 1$，同理，x 的二进制形式的最后一位一定是 1。所以 `x & 1 = 1`。

## 4. 快速求一个数的 n 次幂（$x^n$）

1. 循环/递归
   
   - 使用递归/循环依次计算 $x^1$、$x^2$、$x^3$、... $x^n$
   - 时间复杂度是 $O(n)$，如果是递归的话，空间复杂度是 $O(n)$，非常容易堆内存溢出。
2. 快速幂法
   
   - 以 $2^{64}$ 为例，我们可以采取下面的方式进行计算：$2$ --> $2^2$ --> $2^4$ --> $2^8$ --> $2^{16}$ --> $2^{32}$ --> $2^{64}$
   - 从 x 开始，每次都对上一次计算的结果进行平方，一共只需要 6 次乘法，而不是 63 次
   - 再举一个例子：$2^15$，可以这样求：$2$ --> $2^3$ --> $2^7$ --> $2^15$
   - 从左向右思考，比较复杂，因为要考虑是不是要多乘一次 x
   - 所以，我们从右向左考虑，对于 $x^n$，根据前面的例子，只有下面两种情况：
     1. n 是奇数，则有 $(x^{n/2})^2 * x$，n / 2 向下取整
     2. n 是偶数，则有 $(x^{n/2})^2$
   - 对于每一次折半的 n，我们判断其是不是偶数，如果是偶数，则直接在前面的基础上进行平方，如果是奇数，在平方的基础上再乘 x
   - 当 n 为 0 的时候，任何不为 0 的数字的 0 次幂均为 1，所以此时直接返回 1
   - 当 n 小于 0 的时候，我们也是按照上面的方式进行计算，最后用 1 去除以这个结果
   - 示例：
     ```js
     function myPow(x, n) {
     
            function power(x, n) {
                if (n === 0) {
                    return 1;
                }
                let half = Math.floor(n / 2);
                if (n % 2 === 0) {
     
                    let temp = myPow(x, half);
                    return temp * temp;
                }
                if (n % 2 === 1) {
                    let temp = myPow(x, half);
                    return temp * temp * x;
     
                }
            }
     
            return n > 0 ? power(x, n) : 1 / power(x, -n);
        }
     ```

## 5. 求一个数的平方根

### 1. 二分查找

### 2. 牛顿迭代法

1. 参考资料
   
   - [数学笔记9——牛顿迭代法](https://blog.csdn.net/sunbobosun56801/article/details/78088085)
   - [如何通俗易懂地讲解牛顿迭代法求开方？数值分析？](https://www.zhihu.com/question/20690553)
2. 推导
   ![](./img/Newton-Raphson-method.png)
3. 如何判断收敛
   
   - 当 $x_n$ 与 $x_{n-1}$ 比较接近的时候，我们可以判定 $x_n$ 是比较接近 $f(x) = 0$ 的根 $x_0$。
   - 什么是比较接近呢，我们可以设定一个阈值：$\epsilon$，当 $x_n$ 与 $x_{n-1}$ 的差值小于 $\epsilon$ 时，就认为 $x_n$ 是给定的精度范围内的 $f(x) = 0$ 根。

## 6. 如何快速从 1 - n 中筛选出素数

1. 质数又称素数。指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。
2. 筛选素数方法 1
   
   - 根据素数的定义，我们只需要证明在 1 - n 之间，除了 1 和 n，n 能够被期间的任意一个整数整除，那么 n 就 不是素数，反之 n 就是素数。
   - 实际上我们不需要从 1 到 n，遍历到 $\sqrt{n}$ 即可。
   - 示例：
     ```js
     var countPrimes = function(n) {
            if (n <= 2) {
                return 0;
            }
            let count = 0;
            for (let i = 2; i <= n - 1; i++) {
                if (isPrime(i)) {
                    count++;
                }
            }
     
            // console.log(ret);
     
            return count;
        };
     
        function isPrime(n) {
            for (let j = 2; j <= Math.sqrt(n); j++) {
                if (n % j === 0) {
                    return false;
                }
            }
     
            return true;
        }
     ```
   - 这个算法的缺点是时间复杂度比较高，大约是 $O(n^{1.5})$，当 n 比较大的时候，筛选素数耗费的时间比较长。
3. 筛选素数方法 2 —— 埃拉托斯特尼筛法
   
   - 厄拉多塞是一位古希腊数学家，他在寻找素数时，采用了一种与众不同的方法：先将 2－N 的各数放入表中，然后在 2 的上面画一个圆圈，然后划去 2 的其他倍数；第一个既未画圈又没有被划去的数是 3，将它画圈，再划去 3 的其他倍数；现在既未画圈又没有被划去的第一个数是 5，将它画圈，并划去 5 的其他倍数……依次类推， 一直到所有小于或等于N的各数都画了圈或划去为止。这时，表中画了圈的以及未划去的那些数正好就是小于 N 的素数。参考文献：[埃拉托斯特尼筛法](https://www.cnblogs.com/findwg/p/4901219.html)
   - 图示：
     ![](./img/is-prime.gif)
4. 代码实现：
   
   ```js
   function countPrimes(n) {
         let isPrime = Array(n).fill(1);
         let count = 0;
         for (let i = 2; i < n; i++) {
            if (isPrime[i]) {
               count++;
               for (let j = 2 ; i * j < n; j++) {
                     // 筛选 2 的倍数，3的倍数，5 的倍数，...
                     // 倍数的范围不能超过 n
                     isPrime[i * j] = 0;
               }
            }
         }
   
         return count;
   }
   ```

## 7. 如何反转一个整数

1. 字符串反转（仅限于 JavaScript）
   
   - 数字 --> 字符串 --> 字符串数组 --> 数组反转 --> 字符串 --> 数字
2. 求数字的每一位
   
   - 以 12345 为例，首先获得这个数字的每一位：
     - 12345 --> 5
     - 1234 --> 4
     - 123 --> 3
     - 12 --> 2
     - 1 --> 1
   - 反转：`((((0 * 10 + 5) * 10 + 4) * 10 + 3) * 10 + 2) * 10 + 1`
   - 完成上面的过程需要两步：
     1. 取余数：除以 10 的余数
     2. 取商：除以 10 的商
   - 反转：前一个反转的数字 * 10 + 当前的余数
   - 对于 java、C++ 等语言而言，整数是有范围的，其中 int 型的整数的范围是 $-2^{31}$ - $2^{31} - 1$，以正数为例，$2^{31} - 1 = 2147483647$，那么反转以后，可能会溢出，因此在反转过程中，要关注边界，防止溢出。
   - 下面的内容选自 leetcode 第 7 题的来自于官方解法中 @期望 的评论：
     > 一直纠结于边界条件判断，试图通过比较 MAX_VALUE 和输入数字 n 反转后的每一位，但是反转后发现比较过程中就出现了溢出现象，然后又想通过反转后的数字 reverse 与 MAX_VALUE mod 10 去比较，其实很接近于官方解答了，但判断条件越发复杂，代码逻辑很不优雅。直接看答案了
     > 重点在于 $2^{31}$ 和 $2^{31}-1$ 最大位为 2，也就是说如果数字小于 10 位时不用去考虑越界问题。
     > 等于 10 位时，只用比较反转后的数字 reverse 前 9 位与最大最小值的前 9 位即可。
     > 因为输入数字为 10 位时，最高位不可能超过 2，就是说反转之后 reverse 的最低位最大为 2，不可能超过 7，所以前 9 位不超过最大最小值前 9位时，第10位（最低位）不存在超过最大最小值最低位的情况，也就自然不用关注最低位了。
   - 借鉴这种思路：
     - 考虑反转后的数字，假设输入的数字是 x，一共有 n 位， n <= 10，反转后的数字是 rev，显然 rev 的位数小于等于 n
     - 当 n = 10 的时候，如果 rev 的位数小于 10，显然 rev < $2^{31}-1$
     - 当 rev 的位数等于 10 的时候，由于 x 的最高位肯定为 1 或者 2，那么 rev 的最后一位显然也是 1 或者 2，而 $2^{31} - 1 = 2147483647$，显然小于最大整数的最后一位 7，那么我们只需要考虑前 9 位数的大小即可，如果 rev 的前 9 位数大于最大值的前 9 位数，显然 rev > 2147483647
     - 如果 rev 的前 9 位数小于最大值的前 9 位数，显然 rev < 2147483647
     - 综上，我们只需要比较 rev 和 最大值除以 10 的商（214748364）即可
     - 同理可见 rev 和最小值的关系
     - 即 rev > INT_MAX / 10 或者 rev < INT_MIN / 10
   - 因为 js 的整数范围要大于给定的范围，因此不需要像上面的这种方式进行判断
   - 示例代码：
     ```js
     function reverse(x) {
            let reverseNum = 0;
            while (x !== 0) {
                // 获得个位数
                let remainder = x % 10;
                // 将整数向右移动一位，即除 10 以后的商的部分，如 123 / 10 = 12.3 --> 12，-135 / 10 = -13.5 --> -13
                // 因此，如果是正数，就向下取整，负数就向下取整
                x = x < 0 ? Math.ceil(x / 10) : Math.floor(x / 10);
        // 每次向左移动一位，给个位数腾出位置
                reverseNum = reverseNum * 10  + remainder;
                if (reverseNum < -Math.pow(2, 31) || reverseNum > Math.pow(2, 31) - 1) {
                    return 0;
                }
            }
            return reverseNum;
        }
     ```

## 8. 快速求 $n!$ 中末尾 0 的个数

1. 计算出 $n!$，转换为字符串，统计末尾的 0。$n!$ 增长速度非常快，非常容易溢出，所以通过这个方法统计其末尾的 0 的个数行不通。
2. 考虑一下一个数字末尾的 0 是怎么来的，要想一个数字的末尾出现 0
   
   - 这个数字的因数一定有 10，因为 10 = 2 × 5
   - 换句话说，这个数字的因数中一定有 2 和 5
   - 那么我们去寻找这个数字的因数中 2 和 5 的数量
   - 因为 2 的增长数量远远大于 5，所以我们考虑 5 的数量
   - $10 = 2 × 5$
   - $100 = 4 × 25 =2 × 2 × 5 × 5$
   - $1000 = 8 × 125 = 2 × 2 × 2 × 5 × 5 × 5$
   - ...
3. 观察上面的等式，我们可以发现，一个 5 可以带来一个 0，$5^2$（两个因数 5） 可以带来两个 0，$5^3$ （三个因数 5）可以带来 3 个 0，...，那么除了考虑单个因数 5，还要考虑多个因数 5
4. 以 1 - 50 为例
   
   ```
   1  2  3  4  5  6  7  8  9  10
        11 12 13 14 15 16 17 18 19 20
        21 22 23 24 25 26 27 28 29 30
        31 32 33 34 35 36 37 38 39 40
        41 42 43 44 45 46 47 48 49 50
   ```
5. 从 1 开始，每隔 5 个数，都会有一个 5 或者 5 的倍数，如下：`5 10 15 20 25 30 35 40 45 50`
6. 按照上面的规律，在 5 的倍数的基础上，每隔 5 个数，还会有 5 的倍数，这些倍数就是多个因数 5，如 25，25 依旧会带来末尾的 0，所以我们还需要进行第二次筛选：`25 50`。数量不够 5 个，因此不能进行第三次筛选了
7. 因此，$50!$ 末尾的 0 的个数是 $10 + 2 = 12$
8. 综上，对于 n!，想获得其末尾的 0 的个数，就是求 n 中 5、25、125、... 的数量的总和。
9. 示例代码如下：
   
   ```js
   var trailingZeroes = function(n) {
          let sum = 0;
          let base = 5;
          while (base <= n) {
              sum += Math.floor(n / base);
              base = base * 5;
          }
   
          return sum;
      };
   ```

