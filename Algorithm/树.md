# 数据结构 - 树

## 1. 树的概念

1. 数据结构中，树用来描述一种具有层级关系的数据，如父子孙关系、行政区划、政府部门关系等都是树形结构。

## 2. 树的遍历方式

### 1. 深度优先遍历 -- DFS(Depth First Search)

1. 尽可能深的搜索树的分支。

2. 遍历方式 -- 递归：
   1. 访问根节点
   2. 对根节点的子节点挨个进行深度优先遍历

3. 代码示例：
   ```js
      const tree = {
         val: 'a',
         children: [
             {
                 val: 'b',
                 children: [
                     {
                         val: 'd',
                         children: [
                             {
                                 val: 'h',
                                 children: [
                                     {
                                         val: 'i',
                                         children: [

                                         ]
                                     },
                                 ]
                             },
                         ]
                     },
                     {
                         val: 'e',
                         children: [

                         ]
                     }
                 ]
             },
             {
                 val: 'c',
                 children: [
                     {
                         val: 'f',
                         children: [

                         ]
                     },
                     {
                         val: 'g',
                         children: [

                         ]
                     }
                 ]
             }
         ]
     }

      /**
       * 深度优先遍历
       * @param tree
       */
      const dfs = (tree) => {
          console.log(tree.val);
          tree.children.forEach(dfs);
      }

      // 输出示例
      dfs(tree);
      // a
      // b
      // d
      // h
      // i
      // e
      // c
      // f
      // g
   ```

### 2. 广度优先遍历 -- BFS(Breadth First Search)

1. 优先访问离根节点近的节点。

2. 遍历方式 -- 借助队列：
   1. 新建一个队列，把根节点入队
   2. 队头出队，并访问队头
   3. 把队头的子节点挨个入队
   4. 重复第 2、3 步，直到队列为空

3. 示例代码：
      ```js
      const tree = {
         val: 'a',
         children: [
             {
                 val: 'b',
                 children: [
                     {
                         val: 'd',
                         children: [
                             {
                                 val: 'h',
                                 children: [
                                     {
                                         val: 'i',
                                         children: [

                                         ]
                                     },
                                 ]
                             },
                         ]
                     },
                     {
                         val: 'e',
                         children: [

                         ]
                     }
                 ]
             },
             {
                 val: 'c',
                 children: [
                     {
                         val: 'f',
                         children: [

                         ]
                     },
                     {
                         val: 'g',
                         children: [

                         ]
                     }
                 ]
             }
         ]
     }
       /**
        * 广度优先遍历
        * @param tree
        */
      const bfs = (tree) => {
          const queue = [tree];

          while (queue.length > 0) {
              const first = queue.shift();
              console.log(first.val);
              first.children.forEach(child => {
                  queue.push(child);
              });
          }
      }

      // 输出
      bfs(tree);
      // a
      // b
      // c
      // d
      // e
      // f
      // g
      // h
      // i
   ```
### 3. 先序遍历

1. 二叉树指的是树的每个节点最多有两个子节点。如下所示：
   ```
                           1
                         /   \
                        2     3
                       / \   / \
                      4   5 6   7
                     /   /   \   \
                    8   9    10  11
   ```
2. 在 js 中，使用 Object 模拟二叉树，如下所示：
   ```js
      const binaryTree = {
          val: 1,
          left: {
              val: 2,
              left: null,
              right: null
          },
          right: {
              val: 3,
              left: null,
              right: null
          }
      }
   ```
3. 先序遍历口诀：
   1. 先访问根节点
   2. 对根节点的左子树进行先序遍历
   3. 对根节点的右子树进行先序遍历

4. 由上面的口诀可以看出，先序遍历使用递归，遍历顺序是：根左右。

5. 以下面的二叉树为例：
   ```
                           1
                         /   \
                        2     6
                       / \     \
                      3   4     7
                         /   
                        5    
   ```
   1. 从根节点开始，输出 1。
   2. 对根节点的左子树进行先序遍历，输出 2。
   3. 访问节点 2 的左子树，输出 3，因为节点 3 没有左子树，也没有右子树，所以对节点 3 的先序遍历结束。同时对节点 2 的左子树先序遍历结束。
   4. 访问节点 2 的右子树，输出 4。
   5. 对节点 4 进行先序遍历，访问节点 4 的左子树，输出 5，因为节点 5 没有左右子树，所以节点 5 的先序遍历结束。节点 4 左子树的先序遍历结束，而节点 4 没有右子树，所以节点 4 的先序遍历结束。进而节点 2 的右子树的先序遍历结束。
   6. 访问根节点的右子树（先序遍历），输出 6。节点 6 没有左子树，所以只能对其右子树进行先序遍历。
   7. 访问节点 6 的右子树，输出 7。节点 7 没有左右子树，因此对节点 7 的先序遍历结束。
   8. 对节点 6 的先序遍历结束，整个二叉树的先序遍历结束。输出的顺序为：1234567。

6. 代码实现：
   
### 4. 中序遍历

1. 中序遍历口诀：
   1. 对根节点的左子树进行中序遍历
   2. 访问根节点
   3. 对根节点的右子树进行中序遍历

2. 由上面的口诀可以看出，中序遍历使用递归，遍历顺序是：左根右。

3. 以下面的二叉树为例：
   ```
                           1
                         /   \
                        2     6
                       / \     \
                      3   4     7
                         /   
                        5    
   ```
   1. 对根节点的左子树进行中序遍历。即对节点 2 进行中序遍历，节点 2 存在左右子树，因此先对节点 2 的左子树进行先序遍历。
   2. 访问节点 3，节点 3 没有左子树，因此最先访问根节点，输出 3。节点 3 没有右子树，所以对节点 3 的中序遍历结束。
   
### 5. 后序遍历

1. 后序遍历口诀：
   1. 对根节点的左子树进行后序遍历
   3. 对根节点的右子树进行后序遍历
   2. 访问根节点
   

2. 由上面的口诀可以看出，后序遍历使用递归，遍历顺序是：左右根。

3. 以下面的二叉树为例：
   ```
                           1
                         /   \
                        2     6
                       / \     \
                      3   4     7
                         /   
                        5    
   ```
   
   