# 设计模式 - 单例模式

## 1. 模式说明

1. 单例模式就是一个类只有一个实例，即使我们多次实例化这个类，最后只指向的也只能是第一次创建的那个实例。

2. 全局可以访问这个实例。

3. 可以自行实例化，也可以手动使用 new 关键字实例化。

4. 可以推迟初始化，即延迟执行。

5. 适用场景：
   - 引用一个第三方库，如 jQuery，则全局只需要维护一个 jQuery 实例，即使我们多次引用，也会只引用同一个 jQuery 实例。
   - 弹窗，比如登录弹窗。
   - 购物车，一个用户只能有一个购物车
   - 全局管理的对象，如 redux 的 store

## 1. 简易版单例模式

1. 基本原理
   - 使用一个变量存储这个实例对象，进行实例化的时候，首先判断组个实例对象是否存在，如果存在，则返回这个实例对象，否则返回一个新创建的实例对象。

2. 代码实现 
   ```javascript
      function FruitSingleton(name, color) {
          this.name = name;
          this.color = color;
          this.instance = null;
      }
   
      FruitSingleton.prototype.getColor = function () {
          return `The color is ${this.color}`;
      }
   
      FruitSingleton.getInstance = function (name, color) {
          if (!this.instance) {
              // 关键语句
              this.instance = new FruitSingleton(name, color);
          }
   
          return this.instance;
      }
   ```

2. 关键点
   - 函数在 JavaScript 是一等公民。因此可以给其添加属性和方法。
   - 我们在构造函数上挂载了一个 getInstance 方法，不使用 new，而是使用这个方法获得实例对象。
   - 调用 getInstance 方法获得实例时，首先要判断 this.instance 是否有实例，如果有，则返回这个实例，没有的化，就使用 new 关键字获得一个实例，并赋给 this.instance。这样即使多次调用 getInstance()，也只返回一个实例。

3. 存在问题
   - 不够透明，无法使用 new 关键字来实例化。使用 getInstance() 不够灵活。
   - 管理单例的操作，与创建对象的操作，耦合在一起，功能代码耦合到一起，不符合单一职责的原理。
   
## 2. 透明版单例模式

```javascript
   const Fruit = (function () {
       let instance;
   
       return function (name, color) {
           if (instance) {
               return instance;
           }
           this.name = name;
           this.color = color;
   
           return instance = this;
       }
   })()
   
   Fruit.prototype.getColor = function () {
       return `The fruit color is ${this.color}`;
   }
```

## 3. 代理版单例模式

## 4. 惰性单例模式