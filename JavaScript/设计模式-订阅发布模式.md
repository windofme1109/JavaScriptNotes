# 订阅/发布模式

## 1. 


```javascript
   class Event {
       constructor() {
           // 缓存订阅者绑定的函数
           // this.fnList= [];
           // 缓存事件标识
           this.subscribeObj = {};
       }
   
   
       /**
        *
        * @param key
        * @param fn
        */
       on = (key, fn) => {
           if (typeof fn !== 'function') {
               throw Error('invalid argument');
           }
           // key 是事件名称
           if (!this.subscribeObj[key]) {
               // 创建缓存函数的列表
               this.subscribeObj[key] = [];
           }
           // 将同一事件的回调函数放入缓存数组中
           this.subscribeObj[key].push(fn);
       }
   
       /**
        *
        * @param rest
        */
       emit = (...rest) => {
           // 取出函数的第一个参数，是事件名称
           const key = rest[0];
           // 第二个参数以及后面的参数
           const args = rest.slice(1);
           // 根据 key 取出缓存函数
           const fn = this.subscribeObj[key];
   
           if (!fn || fn.length === 0) {
               // 没有缓存的函数，终止函数执行
               return ;
           }
           // 依次执行缓存的函数
           fn.forEach(f => {
               f.apply(this, args);
           });
       }
   
       /**
        * 移除某个订阅事件的回调函数，注意，移除的不能是匿名函数
        * @param key
        * @param fn
        */
       remove = (key, fn) => {
           // 根据 key 取出缓存的函数列表
           let fnList = this.subscribeObj[key];
           if (!fnList) {
               // 如果没有缓存函数，就终止函数执行
               return;
           }
   
           if (!fn) {
               // 如果没有指定回调函数，那么就清空指定事件的所有的缓存函数
               fnList && (fnList.length = 0);
           }
   
           const length = fnList.length;
           for (let i = 0; i < length; i++) {
               let _fun = fnList[i];
               if (_fun === fn) {
                   // 移除具体的回调函数
                   fnList.splice(i, 1);
               }
           }
   
       }
   }
```