# Key Point

## 1. Yonbuilder 是做什么的

## 2. 低代码平台

## 3. 脚手架的作用

1. 给设计器生成的页面提供扩展开发能力，包括页面功能功能扩展、页面组件扩展和样式扩展的能力。因为设计器生成的页面包含了基本的功能，比如说添加、删除数据、提交等功能，但是这些功能不一定满足客户的需求，因此需要在其基础上，对页面的原有功能进行扩展，或者是开发新的功能。
   - 页面功能扩展指的是按照一定的规则，写一个 js 脚本，然后脚手架将这个脚本自动注入到当前页面，并执行。在脚本中写的功能就能应用到当前页面。
   - 页面组件扩展指的是，我们书写新的组件，并将新的组件挂载到当前的页面上。
   - 样式扩展指的是对自定义修改设计器生成的页面中元素的样式。

2. 使用 webpack 对扩展的 js 和 css 进行打包。

3. 提供一个本地的 http 服务，能够在本地调试扩展的内容。http 服务依赖于 webpack-devServer（WDS）。


## 4. 怎么实现的页面扩展开发能力（怎么实现的扩展）

1. domainKey 是表示开发的单据所属的领域，是一个唯一的值。当前 domainKey 的会有多个应用，每个应用下有若干页面，而每个页面有一个唯一的单据号，也就是 id，那么 domainKey + id 就是我们定义的扩展的文件名。

2. 将每个页面的扩展脚本看作一个模块，使用 AMD 的方式定义模块，即使用 define 函数定义扩展脚本，使用 domainKey 作为模块的表示，而 id 作为模块内部导出的变量名。这个 id 指定的是一个对象，对象内部定义了多个函数，当加载模块时执行这些函数。

3. 使用 AMD 的方式加载模块。即 使用 require 函数对扩展脚本进行加载。因为当前的页面的 url 中包含了 domainKey 和页面单据 id，框架根据这些信息决定加载哪个模块。

## 5. 扩展组件与扩展样式

1. 页面元数据中必须有我们的扩展组件信息，一般是名称，放在 cControlType 字段下。而 cControlType 字段就是用来指定页面中的组件的。

2. 脚手架中定义组件后，需要将其在指定位置导出，且组件名和元数据中的 cControlType 一致。

3. 底层框架根据元数据中 cControlType 指定的组件开始渲染，首先去组件库中查找，如果组件库中没有指定的组件，就去脚手架中寻找，找到以后，将其渲染到页面上。

4. 而扩展样式在指定位置书写，使用 webpack 对其进行打包，生成 extend.css，如果当前是开发环境，那么会请求这个 css 文件，从而将样式应用到页面的元素上。


## 6. 脚手架的中间层（BFF）的作用

1. 数据包装
   - 后端微服务化，提供了较多的单体服务。而渲染页面过程中需要较多的数据，这些数据来自于不同的微服务，如 UI 元数据服务、公式数据服务、参照数据服务等。在前端访问这些服务，并对数据进行剪裁、拼装、组合比较麻烦，而且还需要和后端进行频繁沟通，效率比较低，所以我们将组装、聚合、裁剪这部分业务单独拎出来，放在 BFF 层。

2. 多端应用
   - 脚手架不仅提供 pc 端页面的扩展，也提供移动端的页面扩展，在生成页面的时候，需要访问不同的接口，获得不同的数据，为了减少前端的复杂性，我们把这些功能统一放到 BFF 层。

3. 代理转发
   - 访问接口 A 的请求转发到接口 B。

4. 模板渲染 - SSR
   - 根据请求的部分数据，在 BFF 层生成一个 html 字符串，返回给前端，浏览器能直接渲染这些内容。
   - 部分数据包括静态资源路径、domainKey 信息等

## 7. 怎么实现的代理转发

1. 使用 koa-router 定义多个路由。

2. 在具体的路由处理函数中，对前端发来的请求进行判断，根据请求路径的不同，使用 axios 再次向后端发起请求。

3. 使用 axios 发起请求时，需要重新配置请求的相关信息，如请求方法、请求体、cookies、content-type 等。这些信息都可从 ctx 中取出，也会根据实际需求，添加或者修改一些信息。

4. 在一些请求中，还会使用流的方式对返回的信息进行处理。这些请求和二进制数据相关，如打印等。

## 8. 为什么要使用前端模板，优势是什么

1. 前端模板渲染属于 SSR，即服务端渲染。因为使用设计器生成的前端页面内容比较多，需要请求的接口多，渲染的数据多，如果全部放到前端进行，那么会导致页面渲染慢，白屏时间长，这些对用户体验而言非常不友好。

2. 因此，在 BFF 层做了一个 SSR 功能，前端发起请求页面的请求后，在相应的路由处理函数中，我们向后端发起请求，请求和页面渲染相关的数据，如 css 样式、静态资源地址、部分 ui 元数据等，根据这些新生成一个基本的 html 字符串，然后返回给前端，这样浏览器能直接渲染这个 html 内容，页面就能很快的出来（出来部分页面，其他部分还需要后续请求）。减少了首屏时间，提高了用户的体验。

## 9. 数据包装指的是什么

1. 后端微服务化，提供了较多的单体服务。而渲染页面过程中需要较多的数据，这些数据来自于不同的微服务，如 UI 元数据服务、公式数据服务、参照数据服务等。在前端访问这些服务，并对数据进行剪裁、拼装、组合比较麻烦，而且还需要和后端进行频繁沟通，效率比较低，所以我们将组装、聚合、裁剪这部分业务单独拎出来，放在 BFF 层。

2. 对单个微服务返回的数据进行处理，如字段映射、层级转换等。如果是需要访问多个微服务，那么我们需要将访问这些微服务返回的数据进行拼装、组合等。

3. 经过这样操作，前端拿到的数据能直接用于渲染。缺点就是不了解后端返回的数据的真实样貌，如果由于数据的问题导致的渲染失败，不利于问题排查（不知道出问题的字段的真实样子）。

## 10. Koa2 的中间件原理是什么

1. 洋葱模式。

## 11. 写过哪些 Koa 中间件

1. 设置环境信息中间件
   - 在进行代理转发的时候，需要区分是本地环境还是生产环境。之前的做法是在每个路由中都做处理，进行区分，随着路由的增多，这样的区分方法会带来大量的重复代码，且效率比较低。因此将这部分功能抽出来，单独做一个中间件，在这个中间件内部，根据 cookies、url 中的查询参数、基础配置项的信息判断当前是生产环境还是本地环境，然后将环境信息挂载到 ctx 对象上。

2. 生成模板字符串的中间件
   - 在 ctx 上挂载一个 render 方法，这个方法根据输入的数据生成一份 html 模板。在需要返回 html 的地方，直接调用 render 方法即可。

## 12. 应用构建是做什么的，包括应用引擎、流水线、

1. 表单输入

2. 字段校验

## 13. 附件上传组件是怎么实现的

1. 使用了原生的 input 元素，设置其 type 为 file。

2. 原生的 input 元素获得了上传的文件信息后，使用 form + ajax 的方式实现文件上传。

3. 原生的 input 元素样式不美观，因此将其隐藏。用户可以自定义表示上传的元素。可以是按钮，也可以是图片。那么如何触发上传操作呢，我们这里使用了事件委托机制，利用事件冒泡，在其父元素上绑定点击事件处理函数，当自定义元素被点击后，点击事件向上传递，在父元素上被捕捉到，此时表示有上传操作，那么在点击事件的处理函数中，我们再手动触发 input 元素的 click 事件，就间接模拟了用户的点击 input 元素饿操作。

## 14. 附件下载功能怎么实现的

1. 设置 a 标签的 download 属性

2. 设置了 download 属性，点击 a 标签，就是下载文件，而不是打开新的标签页。但是，浏览器只支持同源下载。如果是跨域下载，则 download 属性不起作用。所以需要我们在后端做一层转发，最终得到的文件下载的 url 和下载页同源即可。

## 15. 上传进度展示是怎么实现的

1. 上传组件使用 ajax 的方式实现文件的上传。发送请求使用的是 axios。axios 配置项中有一个 onUploadProgress 配置项，这个配置项包装了原生的 ajax 的 progress 事件，我们可以用来处理上传进度。progress 事件对象中有一个 loaded 属性表示当前上传的文件字节数，而 total 属性表示文件总的字节数。使用这两个属性就可以实时获得上传的进度。

2. 进度条组件展示下载进度，实际上就是将进度作为元素的 width 属性，为了使得进度变化更加平滑，使用 CSS3 的新特性：translation。

## 16. 开发模态框组件遇到什么问题

## 17. 遇到的比较难以解决的问题有什么

1. 在事件处理函数中获得异步操作返回值
   - 用户点击审批按钮，触发自定义的审批流事件，在事件的处理函数中，返回 true 表示审批流继续向下执行，返回 false 表示审批流终止。然后点击审批按钮以后，会有一个弹窗来提示用户，需要根据确定函数取消来决定审批是否继续。问题就是弹窗的确定和取消的处理函数是异步的，这样我们就无法在审批流事件中拿到异步的结果。
   - 解决方案：使用 async 和 await 将弹窗的异步操作变成同步操作。使用 Promise 封装弹窗操作，在确定的回调中，执行 resolve，在取消的回调中执行 reject。然后在自定义审批流事件的回调中，使用 await 关键字，等待弹窗的最终操作结果，这样就能拿到弹窗的异步操作的返回值。

2. 跨 iframe 通信
   - 应用构建的一些页面是使用的 iframe 引入的其他部门的页面。我们提供一个页签，每个标签对应不同的 iframe 页面。存在一个问题就是，在 iframe 进行编辑、输入操作时，如果不小心点击到外面的标签，则会切换到另外一个页面，用户体验非常不好。
   - 解决方案：在 iframe 进行编辑、输入等操作时，向最顶层的 frame 发送一个消息，表示正在进行编辑、输入操作，标签的点击功能应该被禁用。当退出编辑，再发送一个消息，表示编辑结束，那么可以标签的点击功能可以使用。
   - 在 iframe 中发送的消息，需要在顶层的 frame 中接收，涉及到了跨域通信。使用了 html5 的 postMessage 机制。

3. JavaScript 模拟 hover 操作

4. 开发附件上传组件过程中，如何精确限制文件类型

## 18. 防抖函数

1. 限制某些操作频率，如滚动、文本输入等，这些操作会短时间内触发大量的 scroll 、change 等事件，如果不对事件处理函数的调用频率做出限制，会导致页面的频繁更新，加重浏览器负担，或者频繁发送请求，加重服务器负担。

2. 引入 debounce（防抖）函数，限制事件处理函数的执行频率。当持续触发事件时，只响应最后一次触发的事件：从最后一个触发事件开始计时，在规定的时间间隔内，没有新的事件被触发，那么才会执行事件处理函数，如果有新的事件被触发，那么就中断当前计时，并重新开始计时。 


## 19. 模糊搜索怎么做的

1. 监听的是 input 元素的 change 事件，监听用户的输入，然后将用户的输入发送到后端，将后端返回的数据渲染成列表供用户选择。

2. 因为用户输入的速度比较快，会高频次触发 change 事件，正常情况下会短时间内发送大量请求，这样对服务端的压力比较大，为了减轻服务端的压力，这里使用使用防抖函数来限制发送请求的次数。

## 20. 页面自适应性怎么实现的

1. 使用 flex 布局完成卡片的基本布局

2. 监听 resize 事件，获得当前浏览器窗口的宽度，根据这个宽度，重新调整卡片的宽度，能够和当前的窗口尺寸适应。

3. 设置当前页面的 min-width，当页面宽度小于一定值的时候，出现横向滚动条，卡片大小不再发生变化。

5. 使用了防抖函数，限制 resize 事件处理函数的触发次数，提高页面性能。

## 21. React-Router 原理

1. React-Router 的路由分为两种模式：HashRouter 和 BrowserRouter。HashRouter 是根据 url 中的 hash 部分的变化匹配不同的组件。而 BrowserRouter 则是根据 url 中的 path 部分的变化来匹配不同的组件。

2. HashRouter 的原理是：当地址栏中的 url 中的 hash 部分发生变化的时候，会触发 hashChange 事件。所以我们可以监听 hashChange 事件，然后获取 hash 值，根据 hash 值的不同渲染不同的组件。

3. BrowserRouter 的原理是监听浏览器地址栏中 url 中的 path 部分的变化。有三种情况会导致 path 发生变化：1. 调用 history 的 api，如 go、back、forward；2. 输入url 或者刷新页面；3. 调用 html5 新增的 pushState 或者 replaceState 方法。调用 history 的 api 改变 path 会触发 popState 事件，所以我们可以监听 popState 事件，然后获得 url 中的 path，根据 path 渲染不同的组件。如果是调用 pushState 改变 path，那么我们需要在改变 path 之后，手动更新路由组件，这样可以渲染同当前 path 匹配的 组件。最后就是手动刷新页面或者输入 url，这种情况下会发送请求到后端，所以需要后端做一个重定向，将所有请求重定向到 index.html，这样就能根据根据当前的 path 渲染指定的组件。

